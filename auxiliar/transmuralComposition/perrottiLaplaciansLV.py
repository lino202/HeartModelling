""""Here we apply Regional segmentation of ventricular models to achieve
repolarization dispersion in cardiac electrophysiology modeling
L. E. Perotti1,2,3 , S. Krishnamoorthi1, N. P. Borgstrom2 ,
D. B. Ennis2,3 and W. S. Klug1,*,â€ 
"""

import fenics
# import pandas as pd
import os
import numpy as np
import argparse
from scipy.spatial.distance import cdist
import time 
import meshio

start = time.time()
parser = argparse.ArgumentParser(description="Options")
parser.add_argument('--dataPath',type=str, required=True, help='path to data')
parser.add_argument('--outName',type=str, required=True, help='output name defines type of diffusion (BC) see paper')
# parser.add_argument('--endoLVId',type=int, required=True, help='Id for the endo surface of the LV')
# parser.add_argument('--epiId' ,type=int, required=True, help='Id for the epi surface')
args = parser.parse_args()

outPath = os.path.join(args.dataPath, 'layers')
if not os.path.isdir(outPath): os.mkdir(outPath)

# endoLVRegionId = args.endoLVId
# epiRegionId = args.epiId


def isMemberIdxsRowWise(arr1, arr2, tol = 1E-6, showMem=False):
    if showMem: 
        print("Required Memory: {} GB".format(4 *(arr1.shape[0]) * (arr2.shape[0]) / 1e9))
    else:
        arr1 = np.reshape(arr1, (-1,3))
    idxs = np.min(cdist(arr2,arr1), axis=1) < tol
    return idxs.nonzero()[0]


class Omega(fenics.SubDomain): 
    def __init__(self, array):
        self.array = array
        super().__init__()
    
    def inside(self, x, on_boundary):
        idx = isMemberIdxsRowWise(x, self.array)
        return True if np.size(idx) else False


# Create mesh and define function space
mesh = fenics.Mesh()
f = fenics.XDMFFile(fenics.MPI.comm_world, os.path.join(args.dataPath, 'mesh', "tetmesh.xdmf"))
f.read(mesh)
fenics.info(mesh)
V = fenics.FunctionSpace(mesh, 'Lagrange', 1)

# Get the endo and epi surfaces
# data = pd.read_csv(os.path.join(outPath, "endo_epi.csv"), usecols=['Points_0' , 'Points_1', 'Points_2', 'RegionId'])
# data = data.to_numpy()
# endoLV = data[data[:,3]==endoLVRegionId][:,0:-1]
# epi = data[data[:,3]==epiRegionId][:,0:-1]
endoLV = meshio.read(os.path.join(args.dataPath, 'mesh', 'lv_endo.obj')).points
epi = meshio.read(os.path.join(args.dataPath,    'mesh', 'epi.obj')).points
bmeshPoints = fenics.BoundaryMesh(mesh, "exterior", True).coordinates()


idxs = isMemberIdxsRowWise(endoLV, bmeshPoints, showMem=True)
endoLV = bmeshPoints[idxs,:]
base = np.delete(bmeshPoints, idxs,axis=0)

idxs = isMemberIdxsRowWise(epi, base, showMem=True)
epi = base[idxs,:]
base = np.delete(base, idxs,axis=0)


bcArray0 = endoLV
bcArray1 = epi


boundary0 = Omega(bcArray0)
bcOmega0 = fenics.DirichletBC(V, fenics.Constant(-1), boundary0, method='pointwise')
boundary1 = Omega(bcArray1)
bcOmega1 = fenics.DirichletBC(V, fenics.Constant(1), boundary1, method='pointwise')
bcs = [bcOmega0, bcOmega1]


# Define variational problem
u = fenics.TrialFunction(V)
v = fenics.TestFunction(V)
f = fenics.Constant(0)        
g = fenics.Constant(0)        #Neumann
a = fenics.dot(fenics.grad(u), fenics.grad(v))*fenics.dx
L = f*v*fenics.dx - g*v*fenics.ds

# Compute solution
# cg is the linear iteratively solver, it is changed form 'lu' default as 2M cells meshes run out of memory
u = fenics.Function(V)


problem = fenics.LinearVariationalProblem(a, L, u, bcs)
solver = fenics.LinearVariationalSolver(problem)
solver.parameters["linear_solver"] = 'gmres'
solver.parameters["preconditioner"] = 'ilu'
solver.parameters["krylov_solver"]["absolute_tolerance"] = 1E-6
solver.parameters["krylov_solver"]["relative_tolerance"] = 1E-3
solver.parameters["krylov_solver"]["maximum_iterations"] = 1000
solver.solve()
# fenics.solve(a == L, u, bcs, solver_parameters={'linear_solver':'cg'})


# Save solution to file in VTK format and Txt
#fenics.File(os.path.join(outPath,'{}.pvd'.format(args.outName))) << u

outXdmf= fenics.XDMFFile(fenics.MPI.comm_world, os.path.join(outPath, "{}.xdmf".format(args.outName)))
outXdmf.write(u,0)

#with open(os.path.join(outPath, '{}.txt'.format(args.outName)), "w") as file:
#    file.write("# \n")
#    file.write("# Transmural distance generated by following Perroti et al\n")
#    file.write("# \n")

#    for node in u.compute_vertex_values(mesh):
#        file.write("{:.15f}\n".format(node))

print("Time of entire operation: {} seconds".format(time.time()-start))
