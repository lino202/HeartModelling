""""Here we apply Regional segmentation of ventricular models to achieve
repolarization dispersion in cardiac electrophysiology modeling
L. E. Perotti1,2,3 , S. Krishnamoorthi1, N. P. Borgstrom2 ,
D. B. Ennis2,3 and W. S. Klug1,*,â€ 
"""

import fenics
import pandas as pd
import os
import numpy as np
import argparse
from scipy.spatial.distance import cdist
import time 

start = time.time()
parser = argparse.ArgumentParser(description="Options")
parser.add_argument('--data_path',type=str, required=True, help='path to data')
parser.add_argument('--out_name',type=str, required=True, help='output name defines type of diffusion (BC) see paper')
parser.add_argument('--endoLVId',type=int, required=True, help='Id for the endo surface of the LV')
parser.add_argument('--endoRVId',type=int, required=True, help='Id for the endo surface of the RV')
parser.add_argument('--epiId' ,type=int, required=True, help='Id for the epi surface')
args = parser.parse_args()

dataPath = args.data_path
outName = args.out_name
outPath = os.path.join(dataPath, 'layers')
if not os.path.isdir(outPath): os.mkdir(outPath)

endoLVRegionId = args.endoLVId
endoRVRegionId = args.endoRVId
epiRegionId = args.epiId


def isMemberIdxsRowWise(arr1, arr2, tol = 1E-6, showMem=False):
    if showMem: 
        print("Required Memory: {} GB".format(4 *(arr1.shape[0]) * (arr2.shape[0]) / 1e9))
    else:
        arr1 = np.reshape(arr1, (-1,3))
    idxs = np.min(cdist(arr2,arr1), axis=1) < tol
    return idxs.nonzero()[0]


class Omega(fenics.SubDomain): 
    def __init__(self, array):
        self.array = array
        super().__init__()
    
    def inside(self, x, on_boundary):
        idx = isMemberIdxsRowWise(x, self.array)
        return True if np.size(idx) else False


# Create mesh and define function space
mesh = fenics.Mesh()
f = fenics.XDMFFile(fenics.MPI.comm_world, os.path.join(dataPath, "electra_tetmesh.xdmf"))
f.read(mesh)
fenics.info(mesh)
V = fenics.FunctionSpace(mesh, 'Lagrange', 1)

# Get the endo and epi surfaces
data = pd.read_csv(os.path.join(outPath, "endo_epi.csv"), usecols=['Points_0' , 'Points_1', 'Points_2', 'RegionId'])
data = data.to_numpy()
endoRV = data[data[:,3]==endoRVRegionId][:,0:-1]
endoLV = data[data[:,3]==endoLVRegionId][:,0:-1]
epi = data[data[:,3]==epiRegionId][:,0:-1]
bmeshPoints = fenics.BoundaryMesh(mesh, "exterior", True).coordinates()

idxs = isMemberIdxsRowWise(endoRV, bmeshPoints, showMem=True)
endoRV = bmeshPoints[idxs,:]
base = np.delete(bmeshPoints, idxs,axis=0)

idxs = isMemberIdxsRowWise(endoLV, base, showMem=True)
endoLV = base[idxs,:]
base = np.delete(base, idxs,axis=0)

idxs = isMemberIdxsRowWise(epi, base, showMem=True)
epi = base[idxs,:]
base = np.delete(base, idxs,axis=0)

if "XV" in outName:
    bcArray0 = np.concatenate((endoLV,endoRV), axis=0)
    bcArray1 = epi
elif "RV" in outName:
    bcArray0 = endoRV
    bcArray1 = np.concatenate((endoLV,epi), axis=0)
elif "LV" in outName:
    bcArray0 = endoLV
    bcArray1 = np.concatenate((endoRV,epi), axis=0)
else: raise ValueError("Wring transmural distance Name")

# -------------------------LAPLACE A--------------------

# subdomains = fenics.MeshFunction("size_t", mesh, 1)
# # subdomains.set_all(0)
# boundary = Omega0()
# boundary.mark(subdomains, 1)
# boundary = Omega1()
# boundary.mark(subdomains, 2)
# fenics.File(os.path.join(rootPath, sample, "boundary.pvd"))<<subdomains


boundary0 = Omega(bcArray0)
bcOmega0 = fenics.DirichletBC(V, fenics.Constant(-1), boundary0, method='pointwise')
boundary1 = Omega(bcArray1)
bcOmega1 = fenics.DirichletBC(V, fenics.Constant(1), boundary1, method='pointwise')
bcs = [bcOmega0, bcOmega1]


# Define variational problem
u = fenics.TrialFunction(V)
v = fenics.TestFunction(V)
f = fenics.Constant(0)        
g = fenics.Constant(0)        #Neumann
a = fenics.dot(fenics.grad(u), fenics.grad(v))*fenics.dx
L = f*v*fenics.dx - g*v*fenics.ds

# Compute solution
u = fenics.Function(V)
fenics.solve(a == L, u, bcs)


# Save solution to file in VTK format and Txt
fenics.File(os.path.join(outPath,'{}.pvd'.format(outName))) << u

with open(os.path.join(outPath, '{}.txt'.format(outName)), "w") as file:
    file.write("# \n")
    file.write("# Transmural distance generated by Maxi following Perroti et al\n")
    file.write("# \n")

    for node in u.compute_vertex_values(mesh):
        file.write("{:.15f}\n".format(node))

print("Time of entire operation: {} seconds".format(time.time()-start))