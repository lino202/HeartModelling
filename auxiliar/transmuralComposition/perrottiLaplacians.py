""""Here we apply Regional segmentation of ventricular models to achieve
repolarization dispersion in cardiac electrophysiology modeling
L. E. Perotti1,2,3 , S. Krishnamoorthi1, N. P. Borgstrom2 ,
D. B. Ennis2,3 and W. S. Klug1,*,â€ 
"""

import fenics
import pandas as pd
import os
import numpy as np


dataPath = "/home/maxi/Documents/PhD/Data/DTI_hearts/Data_Electra_DWI/sampleLE_Control2"
outPath = os.path.join(dataPath, 'layers')
if not os.path.isdir(outPath): os.mkdir(outPath)
outName = "transmural_distB"

endoLVRegionId = 2
endoRVRegionId = 1
epiRegionId = 0


def isMemberIdxsRowWise(arr1, arr2, tol = 1E-6):
    idxs = np.where((abs(arr1-arr2[:,None]) <= tol).all(2))
    return idxs[0]


class Omega(fenics.SubDomain): 
    def __init__(self, array):
        self.array = array
        super().__init__()
    
    def inside(self, x, on_boundary):
        idx = isMemberIdxsRowWise(x, self.array)
        return True if np.size(idx) else False


# Create mesh and define function space
mesh = fenics.Mesh()
f = fenics.XDMFFile(fenics.MPI.comm_world, os.path.join(dataPath, "electra_tetmesh.xdmf"))
f.read(mesh)
fenics.info(mesh)
V = fenics.FunctionSpace(mesh, 'Lagrange', 1)

# Get the endo and epi surfaces
data = pd.read_csv(os.path.join(outPath, "endo_epi.csv"), usecols=['Points_0' , 'Points_1', 'Points_2', 'RegionId'])
data = data.to_numpy()
endoRV = data[data[:,3]==endoRVRegionId][:,0:-1]
endoLV = data[data[:,3]==endoLVRegionId][:,0:-1]
epi = data[data[:,3]==epiRegionId][:,0:-1]
bmeshPoints = fenics.BoundaryMesh(mesh, "exterior", True).coordinates()

idxs = isMemberIdxsRowWise(endoRV, bmeshPoints)
endoRV = bmeshPoints[idxs,:]
base = np.delete(bmeshPoints, idxs,axis=0)

idxs = isMemberIdxsRowWise(endoLV, base)
endoLV = base[idxs,:]
base = np.delete(base, idxs,axis=0)

idxs = isMemberIdxsRowWise(epi, base)
epi = base[idxs,:]
base = np.delete(base, idxs,axis=0)

if "A" in outName:
    bcArray0 = np.concatenate((endoLV,endoRV), axis=0)
    bcArray1 = epi
elif "B" in outName:
    bcArray0 = endoRV
    bcArray1 = np.concatenate((endoLV,epi), axis=0)
elif "C" in outName:
    bcArray0 = endoLV
    bcArray1 = np.concatenate((endoRV,epi), axis=0)
else: raise ValueError("Wring transmural distance Name")

# -------------------------LAPLACE A--------------------

# subdomains = fenics.MeshFunction("size_t", mesh, 1)
# # subdomains.set_all(0)
# boundary = Omega0()
# boundary.mark(subdomains, 1)
# boundary = Omega1()
# boundary.mark(subdomains, 2)
# fenics.File(os.path.join(rootPath, sample, "boundary.pvd"))<<subdomains


boundary0 = Omega(bcArray0)
bcOmega0 = fenics.DirichletBC(V, fenics.Constant(-1), boundary0, method='pointwise')
boundary1 = Omega(bcArray1)
bcOmega1 = fenics.DirichletBC(V, fenics.Constant(1), boundary1, method='pointwise')
bcs = [bcOmega0, bcOmega1]


# Define variational problem
u = fenics.TrialFunction(V)
v = fenics.TestFunction(V)
f = fenics.Constant(0)        
g = fenics.Constant(0)        #Neumann
a = fenics.dot(fenics.grad(u), fenics.grad(v))*fenics.dx
L = f*v*fenics.dx - g*v*fenics.ds

# Compute solution
u = fenics.Function(V)
fenics.solve(a == L, u, bcs)


# Save solution to file in VTK format and Txt
fenics.File(os.path.join(outPath,'{}.pvd'.format(outName))) << u

with open(os.path.join(outPath, '{}.txt'.format(outName)), "w") as file:
    file.write("# \n")
    file.write("# Transmural distance generated by Maxi following Perroti et al\n")
    file.write("# \n")

    for node in u.compute_vertex_values(mesh):
        file.write("{:.15f}\n".format(node))